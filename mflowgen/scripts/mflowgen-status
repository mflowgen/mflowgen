#! /usr/bin/env mflowgen-python
#=========================================================================
# mflowgen-status
#=========================================================================
# Print build status for each node
#
# The output should look something like this:
#
#     Status:
#
#      - done  ->  0 : info
#      - done  ->  1 : freepdk-45nm
#      - done  ->  2 : constraints
#      - build ->  3 : cadence-innovus-plugins
#      - build ->  4 : rtl
#      - build ->  5 : synopsys-dc-synthesis
#      - build ->  6 : cadence-innovus-flowsetup
#      - build ->  7 : cadence-innovus-place-route
#
# The status is generated from the dry run commands dumped by the build
# tool (e.g., make -n).
#
#  -h --help     Display this message
#  -v --verbose  Verbose mode
#  -b --backend  Build tool (e.g., make)
#  -n --nodes    Comma-separated list of ordered nodes (e.g., "2-foo,1-bar")
#
# Author : Christopher Torng
# Date   : November 3, 2019
#

import argparse
import os
import re
import subprocess
import sys

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )
  p.add_argument( "-v",  "--verbose",   action="store_true" )
  p.add_argument( "-h",  "--help",      action="store_true" )
  p.add_argument( "-b",  "--backend",   default="make"      )
  p.add_argument( "-s",  "--steps"                          ) # legacy
  p.add_argument( "-n",  "--nodes"                          )
  p.add_argument( "-g",  "--subgraphs", default=""          )
  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------

def main():

  opts = parse_cmdline()

  # Support both opts.node (-n --node) and opts.step (-s --step) flags for
  # nodes to be backwards compatible with deprecated step terminology

  if opts.steps:
    opts.nodes = opts.steps

  # Dump dry run commands from build tool

  if opts.backend == 'make':
    text = subprocess.check_output([ 'make', '-n' ])
  elif opts.backend == 'ninja':
    text = subprocess.check_output([ 'ninja', '-nv' ])
  else:
    assert False, 'Cannot get status from build tool ' + opts.backend

  # Convert ascii byte array to string.

  if type( text ) != str:
    text = ''.join( map( chr, text ) )
  lines = text.split('\n')

  # Identify nodes that must be rebuilt (i.e., check if the dry run
  # commands show that the output stamps need to be updated)

  nodes = opts.nodes.split(',')
  subgraphs = opts.subgraphs.split(',')

  echo_green   = '\033[92m'
  echo_red     = '\033[91m'
  echo_bold    = '\033[1m'
  echo_nocolor = '\033[0m'

  done_str  = echo_green + 'done ' + echo_nocolor
  build_str = echo_red   + 'build' + echo_nocolor

  status = { s: done_str for s in nodes }

  for s in nodes:
    if any([ re.match( r'.*touch ' + s + '/.postconditions.stamp', l ) for l in lines ]):
      status[s] = build_str

  # Check which nodes are prebuilt (i.e., have a special '.prebuilt' file)
  # and check which nodes are subgraphs

  prebuilt_str = echo_bold + ' (pre-built)' + echo_nocolor
  prebuilt = {}
  subgraph_str = echo_bold + ' (subgraph)' + echo_nocolor
  subgraph = {}
  for s in nodes:
    prebuilt[s] = prebuilt_str if os.path.exists( s+'/.prebuilt' ) else ''
    subgraph[s] = subgraph_str if s in subgraphs else ''

  # Get the upcoming build order (by filtering the dry run commands for
  # commands that touch the stamp)

  order = []

  for l in lines:
    m = re.match( '.*touch ([^/]+)/.postconditions.stamp', l )
    if m:
      s = m.group(1)
      if s not in order:
        order.append( s )

  # Report build order

  print()
  print( 'Upcoming build order:' )
  print()

  for node in order:
    print( ' - ' + node )

  # Report status

  print()
  print( 'Status:' )
  print()

  template_str = ' - {status} -> {number:3} : {name}{prebuilt}{subgraph}'

  for node, node_status in sorted( status.items(), # sort numerical order
                              key=lambda x: int(x[0].split('-')[0]) ):
    tokens = node.split('-')
    d = {
      'status'   : node_status,
      'number'   : tokens[0],
      'name'     : '-'.join(tokens[1:]),
      'prebuilt' : prebuilt[node],
      'subgraph' : subgraph[node]
    }
    print( template_str.format( **d ) )

  print()


if __name__ == '__main__':
  main()


